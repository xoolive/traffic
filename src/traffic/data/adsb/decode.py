from __future__ import annotations

import heapq
import logging
import os
import socket
import threading
import time
from datetime import datetime, timedelta, timezone
from operator import itemgetter
from pathlib import Path
from typing import (
    Any,
    Callable,
    Dict,
    Iterable,
    Iterator,
    Optional,
    TextIO,
    Tuple,
    Type,
    TypedDict,
    TypeVar,
    Union,
    cast,
)

import pyModeS as pms
from tqdm.rich import tqdm

import numpy as np
import pandas as pd

from ...core import Flight, Traffic
from ...core.mixins import DataFrameMixin
from ...core.types import ProgressbarType
from ...data.basic.airports import Airport

D = TypeVar("D", bound="ModeS_Decoder")
R = TypeVar("R", bound="RawData")
U = Tuple[int, Tuple[Any, Any]]

_log = logging.getLogger(__name__)

MSG_SIZES = {0x31: 11, 0x32: 16, 0x33: 23, 0x34: 23}


def next_beast_msg(chunk_it: Iterator[bytes]) -> Iterator[bytes]:
    """Iterate in Beast binary feed.

    <esc> "1" : 6 byte MLAT timestamp, 1 byte signal level,
        2 byte Mode-AC
    <esc> "2" : 6 byte MLAT timestamp, 1 byte signal level,
        7 byte Mode-S short frame
    <esc> "3" : 6 byte MLAT timestamp, 1 byte signal level,
        14 byte Mode-S long frame
    <esc> "4" : 6 byte MLAT timestamp, status data, DIP switch
        configuration settings (not on Mode-S Beast classic)
    <esc><esc>: true 0x1a
    <esc> is 0x1a, and "1", "2" and "3" are 0x31, 0x32 and 0x33

    timestamp:
    wiki.modesbeast.com/Radarcape:Firmware_Versions#The_GPS_timestamp
    """
    data = b""
    for chunk in chunk_it:
        data += chunk
        while len(data) >= 23:
            it = data.find(0x1A)
            if it < 0:
                break
            data = data[it:]
            if len(data) < 23:
                break

            if data[1] in [0x31, 0x32, 0x33, 0x34]:
                # The tricky part here is to collapse all 0x1a 0x1a into single
                # 0x1a when they are part of a message (i.e. not followed by
                # "1", "2", "3" or "4")
                msg_size = MSG_SIZES[data[1]]
                ref_idx = 1
                idx = data[ref_idx:msg_size].find(0x1A)
                while idx != -1 and len(data) > msg_size:
                    start = ref_idx + idx
                    ref_idx = start + 1
                    if data[ref_idx] == 0x1A:
                        data = data[:start] + data[ref_idx:]
                    idx = data[ref_idx:msg_size].find(0x1A)
                if idx != -1 or len(data) < msg_size:
                    # calling for next buffer
                    break
                yield data[:msg_size]
                data = data[msg_size:]
            else:
                data = data[1:]
                _log.warning("Probably corrupted message")


def decode_time_default(
    msg: str, time_0: Optional[datetime] = None
) -> datetime:
    return datetime.now(timezone.utc)


def decode_time_radarcape(
    msg: str, time_0: Optional[datetime] = None
) -> datetime:
    now = datetime.now(timezone.utc)
    if time_0 is not None:
        now = time_0
    timestamp = int(msg[4:16], 16)

    nanos = timestamp & 0x00003FFFFFFF
    secs = timestamp >> 30
    ts = now.replace(hour=0, minute=0, second=0, microsecond=0)
    ts += timedelta(seconds=secs, microseconds=nanos / 1000)
    if ts - timedelta(minutes=5) > now:
        ts -= timedelta(days=1)
    return ts


def decode_time_dump1090(
    msg: str, time_0: Optional[datetime] = None
) -> datetime:
    now = datetime.now(timezone.utc)
    if time_0 is not None:
        now = time_0
    else:
        now = now.replace(hour=0, minute=0, second=0, microsecond=0)

    timestamp = int(msg[4:16], 16)
    # dump1090/net_io.c => time (in 12Mhz ticks)
    now += timedelta(seconds=timestamp / 12e6)

    return now


decode_time: dict[str, Callable[[str, Optional[datetime]], datetime]] = {
    "radarcape": decode_time_radarcape,
    "dump1090": decode_time_dump1090,
    "default": decode_time_default,
}


class StoppableThread(threading.Thread):
    """Thread class with a stop() method. The thread itself has to check
    regularly for the to_be_stopped() condition."""

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        # self.daemon = True  # is it redundant?
        self._stop_event = threading.Event()

    def stop(self) -> None:
        self._stop_event.set()

    def to_be_stopped(self) -> bool:
        return self._stop_event.is_set()


# total=False means that some keys can be absent
class Entry(TypedDict, total=False):
    timestamp: datetime
    icao24: str
    callsign: Optional[str]
    latitude: Optional[float]
    longitude: Optional[float]
    altitude: Optional[float]
    geoaltitude: Optional[float]
    groundspeed: Optional[float]
    track: Optional[float]
    vertical_rate: Optional[int]
    onground: Optional[bool]
    squawk: str
    # BDS 4,0
    selected_fms: Optional[int]
    selected_mcp: Optional[int]
    barometric_setting: Optional[float]
    # BDS 4,4
    humidity: Optional[float]
    pressure: Optional[int]
    temperature: Optional[float]
    turbulence: Optional[int]
    windspeed: Optional[int]
    winddirection: Optional[float]
    # BDS 4,5
    wind_shear: Optional[int]
    microburst: Optional[int]
    icing: Optional[int]
    wake_vortex: Optional[int]
    radio_height: Optional[int]
    # BDS 5,0
    roll: Optional[float]
    TAS: Optional[float]
    track_rate: Optional[float]
    # BDS 6,0
    IAS: Optional[float]
    heading: Optional[float]
    Mach: Optional[float]
    vertical_rate_barometric: Optional[int]
    vertical_rate_inertial: Optional[int]
    # Uncertainty
    NIC: Optional[int]
    NUCp: Optional[int]
    NUCv: Optional[int]
    NACp: Optional[int]
    NACv: Optional[int]
    HPL: Optional[float]
    RCu: Optional[int]
    RCv: Optional[int]
    HCR: Optional[float]
    VPL: Optional[float]
    HVE: Optional[float]
    VVE: Optional[float]
    HFM: Optional[float]
    VFM: Optional[float]
    EPU: Optional[int]
    VEPU: Optional[int]
    version: Optional[int]
    pHCR: Optional[float]
    pVPL: Optional[float]
    sil_base: Optional[str]


class Aircraft(object):
    def __init__(self, icao24: str, lat0: float, lon0: float) -> None:
        self.icao24 = icao24
        self._callsign: Optional[str] = None
        self._flight: Optional[Flight] = None
        self.cumul: list[Entry] = []

        self.t0: Optional[datetime] = None
        self.t1: Optional[datetime] = None
        self.tpos: Optional[datetime] = None

        self.m0: Optional[str] = None
        self.m1: Optional[str] = None

        self.lat: Optional[float] = None
        self.lon: Optional[float] = None
        self.alt: Optional[float] = None
        self.trk: Optional[float] = None
        self.spd: Optional[float] = None

        self.lat0: float = lat0
        self.lon0: float = lon0

        self.version: Optional[int] = None
        self.nic_a: Optional[int] = None
        self.nic_bc: Optional[int] = None
        self.nic_s: Optional[int] = None

        self.lock = threading.Lock()

    @property
    def flight(self) -> Optional[Flight]:
        with self.lock:  # access then clear not thread-safe, hence the lock
            df = pd.DataFrame.from_records(self.cumul)
            self.cumul.clear()

        if self._flight is not None:
            if len(df) > 0:
                df = pd.concat([self._flight.data, df], sort=False)
            else:
                df = self._flight.data
            if self.version is not None:
                # remove columns added by nuc_p, nuc_v
                if "HPL" in df.columns:
                    df = df.drop(columns=["HPL", "RCu", "RCv"])
                if "HVE" in df.columns:
                    df = df.drop(columns=["HVE", "VVE"])

        if len(df) == 0:
            return None

        if "callsign" in set(df.columns):
            self._flight = Flight(
                df.assign(
                    callsign=df.callsign.replace("", None)
                    .fillna(method="ffill")
                    .fillna(method="bfill")
                )
            )
        else:
            self._flight = Flight(df)

        return self._flight

    @property
    def callsign(self) -> Optional[str]:
        return self._callsign

    @callsign.setter
    def callsign(self, args: tuple[datetime, str]) -> None:
        t, msg = args
        callsign = pms.adsb.callsign(msg).strip("_")
        if callsign == "":
            return
        self._callsign = callsign
        with self.lock:
            self.cumul.append(
                dict(timestamp=t, icao24=self.icao24, callsign=self._callsign)
            )

    @property
    def speed(self) -> None:
        pass

    @speed.setter
    def speed(self, args: tuple[datetime, str]) -> None:
        t, msg = args
        vdata = pms.adsb.velocity(msg)
        if vdata is None:
            return

        spd, trk, roc, tag = vdata
        if tag != "GS":
            # does it ever happen...
            return
        if (spd is None) or (trk is None):
            return

        self.spd = spd
        self.trk = trk

        delta = pms.adsb.altitude_diff(msg)

        with self.lock:
            self.cumul.append(
                dict(
                    timestamp=t,
                    icao24=self.icao24,
                    groundspeed=spd,
                    track=trk,
                    vertical_rate=roc,
                )
            )
            if delta is not None and self.alt is not None:
                self.cumul[-1]["geoaltitude"] = self.alt + delta

    @property
    def position(self) -> None:
        pass

    @position.setter
    def position(self, args: tuple[datetime, str]) -> None:
        t, msg = args
        oe = pms.adsb.oe_flag(msg)
        setattr(self, "m" + str(oe), msg)
        setattr(self, "t" + str(oe), t)
        m0, m1 = self.m0, self.m1

        if (
            m0 is not None
            and m1 is not None
            and self.t0 is not None
            and self.t1 is not None
            and abs((self.t0 - self.t1).total_seconds()) < 10
        ):
            latlon = pms.adsb.position(
                m0, m1, self.t0, self.t1, self.lat0, self.lon0
            )
        else:
            latlon = None

        if latlon is not None:
            self.tpos = t
            self.lat, self.lon = latlon
            self.alt = pms.adsb.altitude(msg)

            with self.lock:
                self.cumul.append(
                    dict(
                        timestamp=t,
                        icao24=self.icao24,
                        latitude=self.lat,
                        longitude=self.lon,
                        altitude=self.alt,
                        onground=False,
                    )
                )

    @property
    def surface(self) -> None:
        pass

    @surface.setter
    def surface(self, args: tuple[datetime, str]) -> None:
        t, msg = args
        self.lat, self.lon = pms.adsb.surface_position_with_ref(
            msg, self.lat0, self.lon0
        )
        speed, track, _, speed_type, *_ = pms.adsb.surface_velocity(msg)
        if speed_type != "GS":
            _log.warn(f"Ground airspeed for aircraft {self.icao24}")

        # This helps updating current representations
        self.spd = speed
        self.trk = track

        with self.lock:
            self.cumul.append(
                dict(
                    timestamp=t,
                    icao24=self.icao24,
                    latitude=self.lat,
                    longitude=self.lon,
                    groundspeed=speed,
                    track=track,
                    onground=True,
                )
            )

    @property
    def altcode(self) -> None:
        pass

    @altcode.setter
    def altcode(self, args: tuple[datetime, str]) -> None:
        t, msg = args
        from pyModeS import hex2bin

        if set(hex2bin(msg)[19:32]) in [{"0"}, {"1"}]:
            return
        self.alt = pms.common.altcode(msg)
        with self.lock:
            self.cumul.append(
                dict(timestamp=t, icao24=self.icao24, altitude=self.alt)
            )

    @property
    def idcode(self) -> None:
        pass

    @idcode.setter
    def idcode(self, args: tuple[datetime, str]) -> None:
        t, msg = args
        from pyModeS import hex2bin

        if set(hex2bin(msg)[19:32]) in [{"0"}, {"1"}]:
            return
        idcode = pms.common.idcode(msg)
        with self.lock:
            self.cumul.append(
                dict(
                    timestamp=t,
                    icao24=self.icao24,
                    squawk=idcode,
                )
            )

    @property
    def bds20(self) -> None:
        pass

    @bds20.setter
    def bds20(self, args: tuple[datetime, str]) -> None:
        t, msg = args
        callsign = pms.bds.bds20.cs20(msg).strip("_")
        if callsign == "":
            return
        self._callsign = callsign
        with self.lock:
            # in case altitude was already included from altcode (DF 4 or 20)
            # or squawk from idcode (DF5 or 21)
            last_entry = self.cumul[-1] if len(self.cumul) > 0 else None
            if last_entry is not None and last_entry["timestamp"] == t:
                self.cumul[-1] = {
                    **last_entry,
                    **dict(callsign=self._callsign),
                }
            else:
                self.cumul.append(
                    dict(
                        timestamp=t,
                        icao24=self.icao24,
                        callsign=self._callsign,
                    )
                )

    @property
    def bds40(self) -> None:
        pass

    @bds40.setter
    def bds40(self, args: tuple[datetime, str]) -> None:
        t, msg = args
        with self.lock:
            # in case altitude was already included from altcode (DF 4 or 20)
            # or squawk from idcode (DF5 or 21)
            last_entry = self.cumul[-1] if len(self.cumul) > 0 else None
            if last_entry is not None and last_entry["timestamp"] == t:
                self.cumul[-1] = {
                    **last_entry,
                    **dict(
                        # FMS selected altitude (ft)
                        selected_fms=pms.bds.bds40.selalt40fms(msg),
                        # MCP/FCU selected altitude (ft)
                        selected_mcp=pms.bds.bds40.selalt40mcp(msg),
                        # Barometric pressure (mb)
                        barometric_setting=pms.bds.bds40.p40baro(msg),
                    ),
                }

            else:
                self.cumul.append(
                    dict(
                        timestamp=t,
                        icao24=self.icao24,
                        # FMS selected altitude (ft)
                        selected_fms=pms.bds.bds40.selalt40fms(msg),
                        # MCP/FCU selected altitude (ft)
                        selected_mcp=pms.bds.bds40.selalt40mcp(msg),
                        # Barometric pressure (mb)
                        barometric_setting=pms.bds.bds40.p40baro(msg),
                    )
                )

    @property
    def bds44(self) -> None:
        pass

    @bds44.setter
    def bds44(self, args: tuple[datetime, str]) -> None:
        t, msg = args
        windspeed, winddirection = pms.bds.bds44.wind44(msg)
        temperature, alt_temp = pms.bds.bds44.temp44(msg)
        with self.lock:
            # in case altitude was already included from altcode (DF 4 or 20)
            # or squawk from idcode (DF 5 or 21)
            last_entry = self.cumul[-1] if len(self.cumul) > 0 else None
            if last_entry is not None and last_entry["timestamp"] == t:
                self.cumul[-1] = {
                    **last_entry,
                    **dict(
                        # Humidity (%)
                        humidity=pms.bds.bds44.hum44(msg),
                        # Average static pressure (hPa)
                        pressure=pms.bds.bds44.p44(msg),
                        # Static air temperature (C)
                        temperature=temperature,
                        turbulence=pms.bds.bds44.turb44(msg),
                        # Wind speed (kt) and direction (true) (deg)
                        windspeed=windspeed,
                        winddirection=winddirection,
                    ),
                }

            else:
                self.cumul.append(
                    dict(
                        timestamp=t,
                        icao24=self.icao24,
                        # Humidity (%)
                        humidity=pms.bds.bds44.hum44(msg),
                        # Average static pressure (hPa)
                        pressure=pms.bds.bds44.p44(msg),
                        # Static air temperature (C)
                        temperature=temperature,
                        turbulence=pms.bds.bds44.turb44(msg),
                        # Wind speed (kt) and direction (true) (deg)
                        windspeed=windspeed,
                        winddirection=winddirection,
                    )
                )

    @property
    def bds45(self) -> None:
        pass

    @bds45.setter
    def bds45(self, args: tuple[datetime, str]) -> None:
        t, msg = args
        with self.lock:
            # in case altitude was already included from altcode (DF 4 or 20)
            # or squawk from idcode (DF 5 or 21)
            last_entry = self.cumul[-1] if len(self.cumul) > 0 else None
            if last_entry is not None and last_entry["timestamp"] == t:
                self.cumul[-1] = {
                    **last_entry,
                    **dict(
                        # Turbulence level (0-3)
                        turbulence=pms.bds.bds45.turb45(msg),
                        # Wind shear level (0-3)
                        wind_shear=pms.bds.bds45.ws45(msg),
                        # Microburst level (0-3)
                        microburst=pms.bds.bds45.mb45(msg),
                        # Icing level (0-3)
                        icing=pms.bds.bds45.ic45(msg),
                        # Wake vortex level (0-3)
                        wake_vortex=pms.bds.bds45.wv45(msg),
                        # Static air temperature (C)
                        temperature=pms.bds.bds45.temp45(msg),
                        # Average static pressure (hPa)
                        pressure=pms.bds.bds45.p45(msg),
                        # Radio height (ft)
                        radio_height=pms.bds.bds45.rh45(msg),
                    ),
                }

            else:
                self.cumul.append(
                    dict(
                        timestamp=t,
                        icao24=self.icao24,
                        # Turbulence level (0-3)
                        turbulence=pms.bds.bds45.turb45(msg),
                        # Wind shear level (0-3)
                        wind_shear=pms.bds.bds45.ws45(msg),
                        # Microburst level (0-3)
                        microburst=pms.bds.bds45.mb45(msg),
                        # Icing level (0-3)
                        icing=pms.bds.bds45.ic45(msg),
                        # Wake vortex level (0-3)
                        wake_vortex=pms.bds.bds45.wv45(msg),
                        # Static air temperature (C)
                        temperature=pms.bds.bds45.temp45(msg),
                        # Average static pressure (hPa)
                        pressure=pms.bds.bds45.p45(msg),
                        # Radio height (ft)
                        radio_height=pms.bds.bds45.rh45(msg),
                    )
                )

    @property
    def bds50(self) -> None:
        pass

    @bds50.setter
    def bds50(self, args: tuple[datetime, str]) -> None:
        t, msg = args
        with self.lock:
            # in case altitude was already included from altcode (DF 4 or 20)
            # or squawk from idcode (DF5 or 21)
            last_entry = self.cumul[-1] if len(self.cumul) > 0 else None
            if last_entry is not None and last_entry["timestamp"] == t:
                self.cumul[-1] = {
                    **last_entry,
                    **dict(
                        # Ground speed (kt)
                        groundspeed=pms.bds.bds50.gs50(msg),
                        # Roll angle (deg)
                        roll=pms.bds.bds50.roll50(msg),
                        # True airspeed (kt)
                        TAS=pms.bds.bds50.tas50(msg),
                        # True track angle (deg)
                        track=pms.bds.bds50.trk50(msg),
                        # Track angle rate (deg/sec)
                        track_rate=pms.bds.bds50.rtrk50(msg),
                    ),
                }

            else:
                self.cumul.append(
                    dict(
                        timestamp=t,
                        icao24=self.icao24,
                        # Ground speed (kt)
                        groundspeed=pms.bds.bds50.gs50(msg),
                        # Roll angle (deg)
                        roll=pms.bds.bds50.roll50(msg),
                        # True airspeed (kt)
                        TAS=pms.bds.bds50.tas50(msg),
                        # True track angle (deg)
                        track=pms.bds.bds50.trk50(msg),
                        # Track angle rate (deg/sec)
                        track_rate=pms.bds.bds50.rtrk50(msg),
                    )
                )

    @property
    def bds60(self) -> None:
        pass

    @bds60.setter
    def bds60(self, args: tuple[datetime, str]) -> None:
        t, msg = args
        with self.lock:
            # in case altitude was already included from altcode (DF 4 or 20)
            # or squawk from idcode (DF5 or 21)
            last_entry = self.cumul[-1] if len(self.cumul) > 0 else None
            if last_entry is not None and last_entry["timestamp"] == t:
                self.cumul[-1] = {
                    **last_entry,
                    **dict(
                        # Indicated airspeed (kt)
                        IAS=pms.bds.bds60.ias60(msg),
                        # Magnetic heading (deg)
                        heading=pms.bds.bds60.hdg60(msg),
                        # Mach number (-)
                        Mach=pms.bds.bds60.mach60(msg),
                        # Barometric altitude rate (ft/min)
                        vertical_rate_barometric=pms.bds.bds60.vr60baro(msg),
                        # Inertial vertical speed (ft/min)
                        vertical_rate_inertial=pms.bds.bds60.vr60ins(msg),
                    ),
                }

            else:
                self.cumul.append(
                    dict(
                        timestamp=t,
                        icao24=self.icao24,
                        # Indicated airspeed (kt)
                        IAS=pms.bds.bds60.ias60(msg),
                        # Magnetic heading (deg)
                        heading=pms.bds.bds60.hdg60(msg),
                        # Mach number (-)
                        Mach=pms.bds.bds60.mach60(msg),
                        # Barometric altitude rate (ft/min)
                        vertical_rate_barometric=pms.bds.bds60.vr60baro(msg),
                        # Inertial vertical speed (ft/min)
                        vertical_rate_inertial=pms.bds.bds60.vr60ins(msg),
                    )
                )

    @property
    def nuc_p(self) -> None:
        pass

    @nuc_p.setter
    def nuc_p(self, args: tuple[datetime, str]) -> None:
        t, msg = args
        with self.lock:
            nuc_p, hpl, rcu, rcv = pms.adsb.nuc_p(msg)
            current: Entry = dict(
                NUCp=nuc_p,
                # Horizontal Protection Limit
                HPL=hpl,
                # 95% Containment Radius on horizontal position error
                RCu=rcu,
                # 95% Containment Radius on vertical position error
                RCv=rcv,
            )
            last_entry = self.cumul[-1] if len(self.cumul) > 0 else None
            if last_entry is not None and last_entry["timestamp"] == t:
                self.cumul[-1] = {**last_entry, **current}
            else:
                self.cumul.append(
                    dict(timestamp=t, icao24=self.icao24, **current)
                )

    @property
    def nic_v1(self) -> None:
        pass

    @nic_v1.setter
    def nic_v1(self, args: tuple[datetime, str]) -> None:
        t, msg = args
        if self.nic_s is None:
            return
        with self.lock:
            nic, hcr, vpl = pms.adsb.nic_v1(msg, self.nic_s)
            last_entry = self.cumul[-1] if len(self.cumul) > 0 else None
            current: Entry = dict(
                NIC=nic,
                # Horizontal Containment Radius
                HCR=hcr,
                # Vertical Protection Limit
                VPL=vpl,
            )
            if last_entry is not None and last_entry["timestamp"] == t:
                self.cumul[-1] = {**last_entry, **current}
            else:
                self.cumul.append(
                    dict(timestamp=t, icao24=self.icao24, **current)
                )

    @property
    def nic_v2(self) -> None:
        pass

    @nic_v2.setter
    def nic_v2(self, args: tuple[datetime, str]) -> None:
        t, msg = args
        if self.nic_a is None or self.nic_bc is None:
            return
        with self.lock:
            nic, hcr = pms.adsb.nic_v2(msg, self.nic_a, self.nic_bc)
            last_entry = self.cumul[-1] if len(self.cumul) > 0 else None
            current: Entry = dict(
                NIC=nic,
                # Horizontal Containment Radius
                HCR=hcr,
            )
            if last_entry is not None and last_entry["timestamp"] == t:
                self.cumul[-1] = {**last_entry, **current}

            else:
                self.cumul.append(
                    dict(timestamp=t, icao24=self.icao24, **current)
                )

    @property
    def nuc_v(self) -> None:
        pass

    @nuc_v.setter
    def nuc_v(self, args: tuple[datetime, str]) -> None:
        t, msg = args
        with self.lock:
            nuc_v, hve, vve = pms.adsb.nuc_v(msg)
            last_entry = self.cumul[-1] if len(self.cumul) > 0 else None
            current: Entry = dict(
                NUCv=nuc_v,
                # Horizontal Velocity Error
                HVE=hve,
                # Vertical Velocity Error
                VVE=vve,
            )
            if last_entry is not None and last_entry["timestamp"] == t:
                self.cumul[-1] = {**last_entry, **current}
            else:
                self.cumul.append(
                    dict(timestamp=t, icao24=self.icao24, **current)
                )

    @property
    def nac_v(self) -> None:
        pass

    @nac_v.setter
    def nac_v(self, args: tuple[datetime, str]) -> None:
        t, msg = args
        with self.lock:
            nac_v, hfm, vfm = pms.adsb.nac_v(msg)
            last_entry = self.cumul[-1] if len(self.cumul) > 0 else None
            current: Entry = dict(
                NACv=nac_v,
                # Horizontal Figure of Merit for rate (GNSS)
                HFM=hfm,
                # Vertical Figure of Merit for rate (GNSS)
                VFM=vfm,
            )
            if last_entry is not None and last_entry["timestamp"] == t:
                self.cumul[-1] = {**last_entry, **current}
            else:
                self.cumul.append(
                    dict(timestamp=t, icao24=self.icao24, **current)
                )

    @property
    def nac_p(self) -> None:
        pass

    @nac_p.setter
    def nac_p(self, args: tuple[datetime, str]) -> None:
        t, msg = args
        with self.lock:
            epu, vepu, nacp = pms.adsb.nac_p(msg)
            last_entry = self.cumul[-1] if len(self.cumul) > 0 else None
            current: Entry = dict(
                # Estimated Position Uncertainty
                EPU=epu,
                # Vertical Estimated Position Uncertainty
                VEPU=vepu,
                # Navigation Accuracy Category Position
                NACp=nacp,
            )
            if last_entry is not None and last_entry["timestamp"] == t:
                self.cumul[-1] = {**last_entry, **current}
            else:
                self.cumul.append(
                    dict(timestamp=t, icao24=self.icao24, **current)
                )

    @property
    def sil(self) -> None:
        pass

    @sil.setter
    def sil(self, args: tuple[datetime, str]) -> None:
        t, msg = args
        with self.lock:
            phcr, pvpl, base = pms.adsb.sil(msg, self.version)
            last_entry = self.cumul[-1] if len(self.cumul) > 0 else None
            current: Entry = dict(
                version=self.version,
                # Probability exceeding Horizontal Containment Radius
                pHCR=phcr,
                # Probability exceeding Vertical Protection Limit
                pVPL=pvpl,
                sil_base=base,
            )
            if last_entry is not None and last_entry["timestamp"] == t:
                self.cumul[-1] = {**last_entry, **current}
            else:
                self.cumul.append(
                    dict(timestamp=t, icao24=self.icao24, **current)
                )


class AircraftDict(Dict[str, Aircraft]):
    lat0: float
    lon0: float
    decoder: "ModeS_Decoder"

    def __missing__(self, key: str) -> Aircraft:
        self.decoder.on_new_aircraft(key)
        self[key] = value = Aircraft(key, self.lat0, self.lon0)
        return value

    def set_latlon(self, lat0: float, lon0: float) -> None:
        self.lat0 = lat0
        self.lon0 = lon0
        for ac in list(self.values()):
            ac.lat0 = lat0
            ac.lon0 = lon0


class DumpFormat:
    def __init__(self, template: str, sep: str = ",") -> None:
        self.template = template
        self.sep = sep
        self.cols = list(x.strip() for x in template.split(sep))
        time_gen = (i for i, elt in enumerate(self.cols) if elt == "time")
        self.time_index = next(time_gen, None)
        if self.time_index is None:
            msg = "Format invalid: must contain 'time'"
            raise ValueError(msg)

        long_gen = (i for i, elt in enumerate(self.cols) if elt == "longmsg")
        self.msg_index = next(long_gen, None)
        self.splitmsg = slice(18, None)

        if self.msg_index is not None:
            return

        short_gen = (i for i, elt in enumerate(self.cols) if elt == "shortmsg")
        self.msg_index = next(short_gen, None)
        if self.msg_index is None:
            msg = "Format invalid: must contain either 'longmsg' or 'shortmsg'"
            raise ValueError(msg)

        self.splitmsg = slice(None)

    def get_timestamp(self, line: str) -> datetime:
        elts = line.split(self.sep)
        return datetime.fromtimestamp(
            float(elts[self.time_index].strip()), timezone.utc  # type: ignore
        )

    def get_msg(self, line: str) -> str:
        elts = line.split(self.sep)
        return elts[self.msg_index][self.splitmsg].strip()  # type: ignore


class ModeS_Decoder:
    """

    This class implements the full data decoding process with the `pyModeS
    library <https://mode-s.org/api/>`_

    Data is first available as a list of messages per aircraft, but can be
    exported as a :class:`~traffic.core.Traffic` object.

    .. warning::

        The :meth:`from_address`, :meth:`from_dump1090`, and :meth:`from_rtlsdr`
        classmethods start a decoding thread on the creation of the object.  The
        thread can be stopped with a ``decoder.stop()`` call.

    :param reference: A reference location must be provided to decode ground
        messages. A reference can be set as:

        - a tuple of latitude/longitude coordinates
        - a str calling for an :class:`~traffic.core.structure.Airport`
          structure

        If no reference is provided (None), then reference location (latitude=0,
        longitude=0) is considered until more data can be used to readjust the
        reference.

    """

    decode_thread: Optional[StoppableThread]
    timer_thread: Optional[StoppableThread]
    timer_functions: list[
        tuple[pd.Timestamp, pd.Timedelta, Callable[[D], None]]
    ] = list()  # noqa: RUF012

    def __init__(
        self,
        reference: None | str | Airport | tuple[float, float] = None,
        expire_threshold: str | pd.Timedelta = pd.Timedelta("10 minutes"),
        expire_frequency: str | pd.Timedelta = pd.Timedelta("1 minute"),
    ) -> None:
        """ """
        if isinstance(reference, str):
            from ...data import airports

            reference = airports[reference]

        if reference is None:
            _log.warning(
                "No valid reference position provided. Fallback to (0, 0)"
            )
            lat0, lon0 = 0.0, 0.0
        elif isinstance(reference, Airport):
            lat0, lon0 = reference.latlon
        else:
            lat0, lon0 = reference

        self.acs: AircraftDict = AircraftDict()
        self.acs.decoder = self
        self.acs.set_latlon(lat0, lon0)

        self.decode_thread = None
        self.timer_thread = None

        self.expire_threshold = (
            expire_threshold
            if isinstance(expire_threshold, pd.Timedelta)
            else pd.Timedelta(expire_threshold)
        )
        self.expire_frequency = (
            expire_frequency
            if isinstance(expire_frequency, pd.Timedelta)
            else pd.Timedelta(expire_frequency)
        )

    @classmethod
    def on_timer(
        cls, frequency: pd.Timedelta | str
    ) -> Callable[[Callable[[D], None]], Callable[[D], None]]:
        now = pd.Timestamp("now", tz="utc")
        if isinstance(frequency, str):
            frequency = pd.Timedelta(frequency)

        def decorate(function: Callable[[D], None]) -> Callable[[D], None]:
            _log.info(f"Schedule {function.__name__} with {frequency}")
            heapq.heappush(
                cls.timer_functions,
                (now + frequency, frequency, function),
            )
            return function

        return decorate

    def expire_aircraft(self) -> None:
        _log.info("Running expire_aircraft")

        now = pd.Timestamp("now", tz="utc")

        if self.decode_thread and not self.decode_thread.is_alive():
            for icao in list(self.acs):
                self.on_expire_aircraft(icao)

        # for icao, ac in self.acs.items()
        # not compatible with changes in size of the dictionary
        for icao in list(self.acs):
            ac = self.acs[icao]
            if len(ac.cumul) > 0:
                if now - ac.cumul[-1]["timestamp"] >= self.expire_threshold:
                    self.on_expire_aircraft(icao)
            else:
                flight = ac.flight
                if flight is not None:
                    if now - flight.stop >= self.expire_threshold:
                        self.on_expire_aircraft(icao)

    def on_expire_aircraft(self, icao: str) -> None:
        with self.acs[icao].lock:
            del self.acs[icao]

    def on_new_aircraft(self, icao: str) -> None:
        _log.info(f"New aircraft {icao}")

    @classmethod
    def from_file(
        cls: Type[D],
        filename: str | Path,
        reference: str | Airport | tuple[float, float],
        uncertainty: bool = False,
        crc_check: bool = False,
        template: str = "time, longmsg",
        sep: str = ",",
    ) -> D:
        """Decode raw messages dumped in a text file.

        The file should contain for each line at least a timestamp and an
        hexadecimal message, as a CSV-like format.

        :param filename: the path to the file containing the data

        :param reference: the reference location, as specified above

        :param uncertainty: if True, decode also `uncertainty information
            <https://mode-s.org/decode/content/ads-b/7-uncertainty.html>`_

        :param crc_check: if True, perform CRC check on messages and discard
            invalid messages. DF 4, 5, 20 and 21 messages don't have CRC so the
            parameter should be set to False if you only have those messages.

        :param template: the header explaining how data is organised

            Three parameters are accepted:

            - ``time`` represents the timestamp in seconds (float)
            - ``shortmsg`` represents the regular version of the ADS-B
              hexadecimal message (messages of length 28 for ADS-B)
            - ``longmsg`` represents messages containing timestamp information
              as a prefix, as dumped by many decoding softwares, such as
              `dump1090 <https://github.com/MalcolmRobb/dump1090/>`_ or other
              receivers.

            By default, the expected format is ``time, longmsg``
        """

        if isinstance(filename, str):
            filename = Path(filename)

        dumpformat = DumpFormat(template, sep)

        with filename.open("r") as fh:
            all_lines = fh.readlines()
            decoder = cls(reference)
            decoder.process_msgs(
                list(
                    (
                        dumpformat.get_timestamp(line),
                        dumpformat.get_msg(line),
                    )
                    for line in all_lines
                ),
                uncertainty=uncertainty,
                crc_check=crc_check,
            )
            return decoder

    @classmethod
    def from_binary(
        cls: Type[D],
        filename: Union[str, Path],
        reference: Union[str, Airport, tuple[float, float]],
        *,
        uncertainty: bool = False,
        crc_check: bool = True,
        time_fmt: str = "dump1090",
        time_0: Optional[datetime] = None,
        redefine_mag: int = 10,
        fh: Optional[TextIO] = None,
    ) -> D:
        decoder = cls(reference)
        redefine_freq = 2**redefine_mag - 1
        decode_time_here = decode_time.get(time_fmt, decode_time_default)

        def next_in_binary(filename: Union[str, Path]) -> Iterator[bytes]:
            with Path(filename).open("rb") as fh:
                while True:
                    get = fh.read()
                    if len(get) == 0:
                        return
                    yield get

        # We don't know the size of the binary so tqdm.rich does not work
        from tqdm.autonotebook import tqdm

        for i, bin_msg in tqdm(
            enumerate(next_beast_msg(next_in_binary(filename)))
        ):
            if len(bin_msg) < 23:
                continue

            msg = "".join(["{:02x}".format(t) for t in bin_msg])

            now = decode_time_here(msg, time_0)

            if fh is not None:
                fh.write("{},{}\n".format(now.timestamp(), msg))

            if i & redefine_freq == redefine_freq:
                decoder.redefine_reference(now)

            decoder.process(
                now,
                msg[18:],
                uncertainty=uncertainty,
                crc_check=crc_check,
            )

        return decoder

    @classmethod
    def from_rtlsdr(
        cls: Type[D],
        reference: Union[str, Airport, tuple[float, float]],
        file_pattern: str = "~/ADSB_EHS_RAW_%Y%m%d_rtlsdr.csv",
        uncertainty: bool = False,
    ) -> D:  # coverage: ignore
        """Decode raw messages dumped from a RTL-SDR receiver.

        :param reference: the reference location, as specified above
        :param file_pattern: the filename where to dump received hexadecimal
            messages

            Timestamp format specifiers are accepted.

            | Default value: ``"~/ADSB_EHS_RAW_%Y%m%d_rtlsdr.csv"``
            | (The ``~`` character gets expanded as your home directory)

        :param uncertainty: if True, decode also `uncertainty information
            <https://mode-s.org/decode/content/ads-b/7-uncertainty.html>`_

        .. warning::

            This method requires the `pyrtlsdr
            <https://github.com/roger-/pyrtlsdr>`_ optional dependency.

        """

        from .rtlsdr import MyRtlReader

        decoder = cls(reference)

        # dump file
        now = datetime.now(timezone.utc)
        filename = now.strftime(file_pattern)
        today = os.path.expanduser(filename)
        fh = open(today, "a", 1)

        rtlsdr = MyRtlReader(decoder, fh, uncertainty=uncertainty)
        decoder.decode_thread = StoppableThread(target=rtlsdr.run)
        decoder.decode_thread.start()
        return decoder

    @classmethod
    def from_socket(
        cls: Type[D],
        s: socket.socket,
        reference: Union[str, Airport, tuple[float, float]],
        *,
        uncertainty: bool,
        crc_check: bool = True,
        time_fmt: str = "default",
        time_0: Optional[datetime] = None,
        redefine_mag: int = 7,
        fh: Optional[TextIO] = None,
    ) -> D:  # coverage: ignore
        decoder = cls(reference)
        redefine_freq = 2**redefine_mag - 1
        decode_time_here = decode_time.get(time_fmt, decode_time_default)

        def next_in_tcp_socket() -> Iterator[bytes]:
            while True:
                data = s.recv(2048)
                if (
                    decoder.decode_thread is None
                    or decoder.decode_thread.to_be_stopped()
                    or len(data) == 0  # connection dropped
                ):
                    _log.warning("Connection dropped or decoder stopped")
                    s.close()
                    decoder.stop()
                    return
                yield data

        def next_in_udp_socket() -> Iterator[bytes]:
            while True:
                if (
                    decoder.decode_thread is None
                    or decoder.decode_thread.to_be_stopped()
                ):
                    s.close()
                    _log.warning("getting out of UDP socket")
                    return
                data, _addr = s.recvfrom(1024)
                yield data

        next_in_socket = {
            socket.SOCK_STREAM: next_in_tcp_socket,
            socket.SOCK_DGRAM: next_in_udp_socket,
        }

        def decode() -> None:
            for i, bin_msg in enumerate(
                next_beast_msg(next_in_socket[s.type]())
            ):
                msg = "".join(["{:02x}".format(t) for t in bin_msg])

                # Timestamp decoding
                now = decode_time_here(msg, time_0)

                if fh is not None:
                    fh.write("{},{}\n".format(now.timestamp(), msg))

                if len(bin_msg) < 23:
                    continue

                if (
                    time_fmt != "radarcape"
                    and i & redefine_freq == redefine_freq
                ):
                    decoder.redefine_reference(now)

                decoder.process(
                    now,
                    msg[18:],
                    uncertainty=uncertainty,
                    crc_check=crc_check,
                )

        def timer() -> None:
            assert decoder.decode_thread is not None

            # This one is automatically added
            cls.on_timer(decoder.expire_frequency)(cls.expire_aircraft)

            # if the decoder is not alive, finish expiring aircraft
            while decoder.decode_thread.is_alive():
                now = pd.Timestamp("now", tz="utc")
                t, delta, operation = heapq.heappop(cls.timer_functions)

                if now < t:
                    wait = t - now
                    time.sleep(wait.total_seconds())

                now = pd.Timestamp("now", tz="utc")
                operation(decoder)
                _log.info(f"Schedule {operation.__name__} at {now + delta}")
                heapq.heappush(
                    cls.timer_functions, (now + delta, delta, operation)
                )

        decoder.decode_thread = StoppableThread(target=decode)
        decoder.decode_thread.start()
        decoder.timer_thread = StoppableThread(target=timer)
        decoder.timer_thread.start()
        return decoder

    def stop(self) -> None:
        if self.decode_thread is not None and self.decode_thread.is_alive():
            self.decode_thread.stop()
            if self.timer_thread is not None:
                self.timer_thread.join()

    def __del__(self) -> None:
        self.stop()

    @classmethod
    def from_dump1090(
        cls: Type[D],
        reference: Union[str, Airport, tuple[float, float]],
        file_pattern: str = "~/ADSB_EHS_RAW_%Y%m%d_dump1090.csv",
        uncertainty: bool = False,
    ) -> D:  # coverage: ignore
        """Decode raw messages dumped from `dump1090
        <https://github.com/MalcolmRobb/dump1090/>`_

        :param reference: the reference location, as specified above
        :param file_pattern: the filename where to dump received hexadecimal
            messages

            Timestamp format specifiers are accepted.

            | Default value: ``"~/ADSB_EHS_RAW_%Y%m%d_dump1090.csv"``
            | (The ``~`` character gets expanded as your home directory)

        :param uncertainty: if True, decode also `uncertainty information
            <https://mode-s.org/decode/content/ads-b/7-uncertainty.html>`_

        .. warning::

            dump1090 must be run the ``--net`` option.

        """
        now = datetime.now(timezone.utc)
        filename = now.strftime(file_pattern)
        today = os.path.expanduser(filename)
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect(("localhost", 30005))
        fh = open(today, "a", 1)
        return cls.from_socket(
            s,
            reference,
            uncertainty=uncertainty,
            time_fmt="dump1090",
            time_0=now,
            fh=fh,
        )

    @classmethod
    def from_address(
        cls: Type[D],
        host: str,
        port: int,
        reference: Union[str, Airport, tuple[float, float]],
        file_pattern: str = "~/ADSB_EHS_RAW_%Y%m%d_tcp.csv",
        time_fmt: str = "radarcape",
        uncertainty: bool = False,
        tcp: bool = True,
    ) -> D:  # coverage: ignore
        """Decode raw messages transmitted over a TCP or UDP network.

        The file should contain for each line at least a timestamp and an
        hexadecimal message, as a CSV-like format.

        :param host: the IP address of the host to connect
        :param port: the port of the host to connect
        :param reference: the reference location, as specified above
        :param file_pattern: the filename where to dump received hexadecimal
            messages

            Timestamp format specifiers are accepted.

            | Default value: ``"~/ADSB_EHS_RAW_%Y%m%d_tcp.csv"``
            | (The ``~`` character gets expanded as your home directory)

        :param time_fmt: (default: ``"radarcape"``)

            - if set to ``"radarcape"``, timestamp information included in the
              long message is assumed to be GPS adjusted and is therefore used
              to adjust the timestamp of each message;
            - if set to ``"dump1090"``, clock information provided by the
              software is used to adjust the timestamp of each message, but the
              first timestamp is based on the computer clock;
            - if set to ``"default"``, the timestamp from the computer is used
              for all decoded messages

        :param uncertainty: if True, decode also `uncertainty information
            <https://mode-s.org/decode/content/ads-b/7-uncertainty.html>`_

        """
        now = datetime.now(timezone.utc)
        filename = now.strftime(file_pattern)
        today = os.path.expanduser(filename)
        if tcp:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect((host, port))
        else:
            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            s.bind((host, port))
        fh = open(today, "a", 1)
        return cls.from_socket(
            s, reference, uncertainty=uncertainty, time_fmt=time_fmt, fh=fh
        )

    def redefine_reference(self, time: datetime) -> None:
        pos = list(
            (ac.lat, ac.lon)
            for ac in list(self.acs.values())
            if ac.alt is not None
            and ac.alt < 5000
            and ac.tpos is not None
            and (time - ac.tpos).total_seconds() < 20 * 60
        )
        n = len(pos)
        if n > 0:
            sum_lat = cast(float, sum(a[0] for a in pos))
            sum_lon = cast(float, sum(a[1] for a in pos))
            self.acs.set_latlon(sum_lat / n, sum_lon / n)

    def process_msgs(
        self,
        msgs: Iterable[tuple[datetime, str]],
        uncertainty: bool = False,
        crc_check: bool = True,
    ) -> None:
        for i, (t, msg) in tqdm(enumerate(msgs), total=sum(1 for _ in msgs)):
            if i & 127 == 127:
                self.redefine_reference(t)
            self.process(t, msg, uncertainty=uncertainty, crc_check=crc_check)

    def process(
        self,
        time: datetime,
        msg: str,
        *args: Any,
        uncertainty: bool = False,
        crc_check: bool = True,
        spd: Optional[float] = None,
        trk: Optional[float] = None,
        alt: Optional[float] = None,
    ) -> None:
        ac: Aircraft

        if len(msg) != 28:
            return

        df = pms.df(msg)

        if df == 4 or df == 20:
            icao = pms.icao(msg)
            if icao is None:
                return
            ac = self.acs[icao.lower()]
            ac.altcode = time, msg  # type: ignore

        if df == 5 or df == 21:
            icao = pms.icao(msg)
            if icao is None:
                return
            ac = self.acs[icao.lower()]
            ac.idcode = time, msg  # type: ignore

        if df == 11:
            # CRC check is valid for DF 11, 17 and 18
            # We use DF 11 messages to create aircraft when they come with no
            # ADS-B data
            icao = pms.icao(msg)
            if icao is None:
                return
            if crc_check and pms.crc(msg, encode=False) != 0:
                return
            ac = self.acs[icao.lower()]

        if df == 17 or df == 18:  # ADS-B
            if crc_check and pms.crc(msg, encode=False) != 0:
                return

            tc = pms.adsb.typecode(msg)
            icao = pms.icao(msg)
            if icao is None or tc is None:
                return

            ac = self.acs[icao.lower()]

            if 1 <= tc <= 4:
                ac.callsign = time, msg  # type: ignore

            if 5 <= tc <= 8:
                ac.surface = time, msg  # type: ignore

            if tc == 19:
                ac.speed = time, msg  # type: ignore

            if 9 <= tc <= 18:
                # This is barometric altitude
                ac.position = time, msg  # type: ignore

            if 20 <= tc <= 22:
                # Only GNSS altitude
                pass

            if not uncertainty:
                return

            if 9 <= tc <= 18:
                ac.nic_bc = pms.adsb.nic_b(msg)

            if (5 <= tc <= 8) or (9 <= tc <= 18) or (20 <= tc <= 22):
                ac.nuc_p = time, msg  # type: ignore
                if ac.version == 1:
                    ac.nic_v1 = time, msg  # type: ignore
                elif ac.version == 2:
                    ac.nic_v2 = time, msg  # type: ignore

            if tc == 19:
                ac.nuc_v = time, msg  # type: ignore
                if ac.version in [1, 2]:
                    ac.nac_v = time, msg  # type: ignore

            if tc == 29:
                ac.sil = time, msg  # type: ignore
                ac.nac_p = time, msg  # type: ignore

            if tc == 31:
                ac.version = pms.adsb.version(msg)
                ac.sil = time, msg  # type: ignore
                ac.nac_p = time, msg  # type: ignore

                if ac.version == 1:
                    ac.nic_s = pms.adsb.nic_s(msg)
                elif ac.version == 2:
                    ac.nic_a, ac.nic_bc = pms.adsb.nic_a_c(msg)

        elif df == 20 or df == 21:
            bds = pms.bds.infer(msg)
            icao = pms.icao(msg)
            # if isinstance(icao, bytes):
            #     icao = icao.decode()
            if icao is None:
                return

            ac = self.acs[icao.lower()]

            if bds == "BDS20":
                ac.bds20 = time, msg  # type: ignore
                return

            if bds == "BDS40":
                ac.bds40 = time, msg  # type: ignore
                return

            if bds == "BDS44":
                ac.bds44 = time, msg  # type: ignore
                return

            if bds == "BDS45":
                ac.bds45 = time, msg  # type: ignore
                return

            if bds == "BDS50,BDS60":
                if spd is not None and trk is not None and alt is not None:
                    bds = pms.bds.is50or60(msg, spd, trk, alt)
                elif (
                    ac.spd is not None
                    and ac.trk is not None
                    and ac.alt is not None
                ):
                    bds = pms.bds.is50or60(msg, ac.spd, ac.trk, ac.alt)
                else:
                    return
                # do not return!

            if bds == "BDS50":
                ac.bds50 = time, msg  # type: ignore
                return

            if bds == "BDS60":
                ac.bds60 = time, msg  # type: ignore
                return

    @property
    def aircraft(self) -> list[Dict[str, Any]]:
        return sorted(
            (
                dict(
                    icao24=key,
                    callsign=ac.callsign,
                    length=(
                        (len(ac.cumul) + len(ac._flight))
                        if ac._flight is not None
                        else len(ac.cumul)
                    ),
                    position=ac.lat is not None,
                    data=ac,
                )
                # avoid dictionary change size during iteration
                for (key, ac) in list(self.acs.items())
            ),
            key=itemgetter("length"),
            reverse=True,
        )

    @property
    def traffic(self) -> None | Traffic:
        """
        :return: All decoded data is converted into a
            :class:`~traffic.core.Traffic` object.

        """
        try:
            return Traffic.from_flights(
                self[elt["icao24"]] for elt in self.aircraft
            )
        except ValueError as e:
            _log.warning(e)
            return None

    def __getitem__(self, icao: str) -> Optional[Flight]:
        with self.acs[icao].lock:
            ac = self.acs[icao]
        return ac.flight


def encode_time_dump1090(times: pd.Series) -> pd.Series:
    if isinstance(times.iloc[0], pd.datetime):
        times = times.astype(np.int64) * 1e-9
    ref_time = times.iloc[0]
    rel_times = times - ref_time
    rel_times = rel_times * 12e6
    rel_times = rel_times.apply(lambda row: hex(int(row))[2:].zfill(12))
    return rel_times


encode_time: Dict[str, Callable[[pd.Series], pd.Series]] = {
    "dump1090": encode_time_dump1090
}


class RawData(DataFrameMixin):
    def __init__(self, data: pd.DataFrame, *args: Any, **kwargs: Any) -> None:
        super().__init__(data, *args, **kwargs)

        for column_name in ["timestamp", "mintime", "maxtime"]:
            if column_name in self.data.columns:
                if data[column_name].dtype == np.float64:
                    self.data = self.data.assign(
                        **{
                            column_name: pd.to_datetime(
                                data[column_name], unit="s", utc=True
                            )
                        }
                    )

    def __add__(self: R, other: R) -> R:
        return self.__class__.from_list([self, other])

    @classmethod
    def from_list(cls: Type[R], elts: Iterable[Optional[R]]) -> R:
        res = cls(
            pd.concat(list(x.data for x in elts if x is not None), sort=False)
        )
        return res.sort_values("mintime")

    def decode(
        self: R,
        reference: Union[None, str, Airport, Tuple[float, float]] = None,
        *,
        uncertainty: bool = False,
        # assume that data you get from a file or DB is already CRC-checked
        crc_check: bool = False,
        progressbar: Union[bool, ProgressbarType[U]] = True,
        progressbar_kw: Optional[Dict[str, Any]] = None,
        redefine_mag: int = 10,
    ) -> Optional[Traffic]:
        decoder = ModeS_Decoder(reference)
        redefine_freq = 2**redefine_mag - 1

        if progressbar is True:
            if progressbar_kw is None:
                progressbar_kw = dict()

            def custom_tqdm(x: Iterable[U]) -> Iterable[U]:
                return tqdm(  # type: ignore
                    x, total=self.data.shape[0], **progressbar_kw
                )

            progressbar = custom_tqdm
        elif progressbar is False:

            def identity(x: Iterable[U]) -> Iterable[U]:
                return x

            progressbar = identity

        data = self.data.rename(  # fill with other common renaming rules
            columns={
                "mintime": "timestamp",
                "time": "timestamp",
                "groundspeed": "spd",
                "speed": "spd",
                "altitude": "alt",
                "track": "trk",
            }
        )

        use_extra = all(x in data.columns for x in ["alt", "spd", "trk"])

        for i, (_, line) in progressbar(enumerate(data.iterrows())):
            extra = (
                dict(
                    spd=line.spd,
                    trk=line.trk,
                    alt=line.alt,
                    crc_check=crc_check,
                    uncertainty=uncertainty,
                )
                if use_extra
                else dict(uncertainty=uncertainty, crc_check=crc_check)
            )

            decoder.process(line.timestamp, line.rawmsg, **extra)

            if i & redefine_freq == redefine_freq:
                decoder.redefine_reference(line.timestamp)

        return decoder.traffic

    def assign_type(self) -> "RawData":
        def get_typecode(msg: str) -> Optional[int]:
            tc = pms.adsb.typecode(msg)
            if tc is None:
                return None
            elif 9 <= tc <= 18:
                return 3
            elif tc == 19:
                return 4
            elif 1 <= tc <= 4:
                return 1
            else:
                return None

        return self.assign(msg_type=lambda df: df.rawmsg.apply(get_typecode))

    def assign_beast(self, time_fmt: str = "dump1090") -> "RawData":
        # Only one time encoder implemented for now
        encoder = encode_time.get(time_fmt, encode_time_dump1090)

        return self.assign(encoded_time=lambda df: encoder(df.mintime)).assign(
            beast=lambda df: "@" + df.encoded_time + df.rawmsg
        )

    def to_beast(self, time_fmt: str = "dump1090") -> pd.Series:
        return self.assign_beast(time_fmt).data["beast"]
